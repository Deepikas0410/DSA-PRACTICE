
âœ… Brute Force vs Hashing â€“ Concepts, Usage & Real-life Examples

ðŸ’¥ 1. What is Brute Force?
Brute Force is the simplest technique in problem-solving.
It means trying all possible combinations or checking every element without applying any optimization.

ðŸ”¸ When to use Brute Force:
- When you donâ€™t know any better optimized solution yet.
- If input size is small (e.g., â‰¤ 1000).
- During initial learning phase.
- To verify the correctness of more optimized solutions.

ðŸ”¸ Real-Life Example:
Imagine you lost your keys and you donâ€™t remember where they are.
You open every drawer one by one to check.
ðŸ‘‰ That is Brute Force.

ðŸ”¸ C++ Example: Two Sum (Brute Force)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i + 1; j < nums.size(); ++j) {
                if (nums[i] + nums[j] == target)
                    return {i, j};
            }
        }
        return {}; 
    }
};

ðŸ•’ Time Complexity: O(nÂ²)
ðŸ§  Easy to write, but slow for large inputs.

âš¡ 2. What is Hashing?
Hashing uses a data structure like unordered_map or unordered_set (in C++)
to store elements such that lookup, insert, and delete operations are fast (average O(1)).

ðŸ”¸ When to use Hashing:
- When you need to:
  - Check if an element exists
  - Count frequency of elements
  - Detect duplicates
  - Find pairs/subarrays/substrings efficiently
- When time matters and you want to optimize from O(nÂ²) to O(n).

ðŸ”¸ Real-Life Example:
Imagine you want to check if a student exists in your college records.
You don't go searching physically in every class.
Instead, you type their roll number in a system and get the result instantly.
ðŸ‘‰ That is Hashing.

ðŸ”¸ C++ Example: Two Sum (Hashing)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> seen; 
        for (int i = 0; i < nums.size(); ++i) {
        	int req = target - nums[i];
            if (seen.count(req))
                return {seen[req], i};
        seen[nums[i]] = i;
        }
        return {}; 
    }
};

ðŸ•’ Time Complexity: O(n)
ðŸ’¾ Space Complexity: O(n)

ðŸ“Œ Comparison Table
| Feature              | Brute Force           | Hashing                     |
|----------------------|------------------------|------------------------------|
| Time Complexity       | O(nÂ²)                  | O(n)                         |
| Space Complexity      | O(1)                   | O(n)                         |
| Uses                  | Try all combinations   | Fast search, lookup          |
| Best For              | Small inputs, learning | Large inputs, optimizations  |

ðŸš¦ When to Use Which?
| Problem Type                        | Recommended Technique      |
|-------------------------------------|-----------------------------|
| Checking if two elements sum to target | Brute â†’ Hashing            |
| Checking if an element exists       | Hashing (unordered_set)     |
| Finding frequency of elements       | Hashing (unordered_map)     |
| Removing duplicates from array      | Hashing                     |
| Longest subarray/substring problems | Hashing + Sliding Window    |

âœ… Final Tip:
âœ”ï¸ Always start with Brute Force if you are new to the problem.
âœ”ï¸ Then optimize with Hashing once your logic is clear.
