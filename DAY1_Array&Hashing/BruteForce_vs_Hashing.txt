
✅ Brute Force vs Hashing – Concepts, Usage & Real-life Examples

💥 1. What is Brute Force?
Brute Force is the simplest technique in problem-solving.
It means trying all possible combinations or checking every element without applying any optimization.

🔸 When to use Brute Force:
- When you don’t know any better optimized solution yet.
- If input size is small (e.g., ≤ 1000).
- During initial learning phase.
- To verify the correctness of more optimized solutions.

🔸 Real-Life Example:
Imagine you lost your keys and you don’t remember where they are.
You open every drawer one by one to check.
👉 That is Brute Force.

🔸 C++ Example: Two Sum (Brute Force)
bool hasPairWithSum(vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        for (int j = i + 1; j < arr.size(); ++j) {
            if (arr[i] + arr[j] == target)
                return true;
        }
    }
    return false;
}

🕒 Time Complexity: O(n²)
🧠 Easy to write, but slow for large inputs.

⚡ 2. What is Hashing?
Hashing uses a data structure like unordered_map or unordered_set (in C++)
to store elements such that lookup, insert, and delete operations are fast (average O(1)).

🔸 When to use Hashing:
- When you need to:
  - Check if an element exists
  - Count frequency of elements
  - Detect duplicates
  - Find pairs/subarrays/substrings efficiently
- When time matters and you want to optimize from O(n²) to O(n).

🔸 Real-Life Example:
Imagine you want to check if a student exists in your college records.
You don't go searching physically in every class.
Instead, you type their roll number in a system and get the result instantly.
👉 That is Hashing.

🔸 C++ Example: Two Sum (Hashing)
bool hasPairWithSum(vector<int>& arr, int target) {
    unordered_set<int> s;
    for (int x : arr) {
        if (s.count(target - x)) return true;
        s.insert(x);
    }
    return false;
}

🕒 Time Complexity: O(n)
💾 Space Complexity: O(n)

📌 Comparison Table
| Feature              | Brute Force           | Hashing                     |
|----------------------|------------------------|------------------------------|
| Time Complexity       | O(n²)                  | O(n)                         |
| Space Complexity      | O(1)                   | O(n)                         |
| Uses                  | Try all combinations   | Fast search, lookup          |
| Best For              | Small inputs, learning | Large inputs, optimizations  |

🚦 When to Use Which?
| Problem Type                        | Recommended Technique      |
|-------------------------------------|-----------------------------|
| Checking if two elements sum to target | Brute → Hashing            |
| Checking if an element exists       | Hashing (unordered_set)     |
| Finding frequency of elements       | Hashing (unordered_map)     |
| Removing duplicates from array      | Hashing                     |
| Longest subarray/substring problems | Hashing + Sliding Window    |

✅ Final Tip:
✔️ Always start with Brute Force if you are new to the problem.
✔️ Then optimize with Hashing once your logic is clear.
