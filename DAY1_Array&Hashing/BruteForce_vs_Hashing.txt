
✅ Brute Force vs Hashing – Concepts, Usage & Real-life Examples

💥 1. What is Brute Force?
Brute Force is the simplest technique in problem-solving.
It means trying all possible combinations or checking every element without applying any optimization.

🔸 When to use Brute Force:
- When you don’t know any better optimized solution yet.
- If input size is small (e.g., ≤ 1000).
- During initial learning phase.
- To verify the correctness of more optimized solutions.

🔸 Real-Life Example:
Imagine you lost your keys and you don’t remember where they are.
You open every drawer one by one to check.
👉 That is Brute Force.

🔸 C++ Example: Two Sum (Brute Force)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i + 1; j < nums.size(); ++j) {
                if (nums[i] + nums[j] == target)
                    return {i, j};
            }
        }
        return {}; 
    }
};

🕒 Time Complexity: O(n²)
🧠 Easy to write, but slow for large inputs.

⚡ 2. What is Hashing?
Hashing uses a data structure like unordered_map or unordered_set (in C++)
to store elements such that lookup, insert, and delete operations are fast (average O(1)).

🔸 When to use Hashing:
- When you need to:
  - Check if an element exists
  - Count frequency of elements
  - Detect duplicates
  - Find pairs/subarrays/substrings efficiently
- When time matters and you want to optimize from O(n²) to O(n).

🔸 Real-Life Example:
Imagine you want to check if a student exists in your college records.
You don't go searching physically in every class.
Instead, you type their roll number in a system and get the result instantly.
👉 That is Hashing.

🔸 C++ Example: Two Sum (Hashing)
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> seen; 
        for (int i = 0; i < nums.size(); ++i) {
        	int req = target - nums[i];
            if (seen.count(req))
                return {seen[req], i};
        seen[nums[i]] = i;
        }
        return {}; 
    }
};

🕒 Time Complexity: O(n)
💾 Space Complexity: O(n)

📌 Comparison Table
| Feature              | Brute Force           | Hashing                     |
|----------------------|------------------------|------------------------------|
| Time Complexity       | O(n²)                  | O(n)                         |
| Space Complexity      | O(1)                   | O(n)                         |
| Uses                  | Try all combinations   | Fast search, lookup          |
| Best For              | Small inputs, learning | Large inputs, optimizations  |

🚦 When to Use Which?
| Problem Type                        | Recommended Technique      |
|-------------------------------------|-----------------------------|
| Checking if two elements sum to target | Brute → Hashing            |
| Checking if an element exists       | Hashing (unordered_set)     |
| Finding frequency of elements       | Hashing (unordered_map)     |
| Removing duplicates from array      | Hashing                     |
| Longest subarray/substring problems | Hashing + Sliding Window    |

✅ Final Tip:
✔️ Always start with Brute Force if you are new to the problem.
✔️ Then optimize with Hashing once your logic is clear.
