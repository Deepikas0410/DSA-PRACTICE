
âœ… Brute Force vs Hashing â€“ Concepts, Usage & Real-life Examples

ğŸ’¥ 1. What is Brute Force?
Brute Force is the simplest technique in problem-solving.
It means trying all possible combinations or checking every element without applying any optimization.

ğŸ”¸ When to use Brute Force:
- When you donâ€™t know any better optimized solution yet.
- If input size is small (e.g., â‰¤ 1000).
- During initial learning phase.
- To verify the correctness of more optimized solutions.

ğŸ”¸ Real-Life Example:
Imagine you lost your keys and you donâ€™t remember where they are.
You open every drawer one by one to check.
ğŸ‘‰ That is Brute Force.

ğŸ”¸ C++ Example: Two Sum (Brute Force)
bool hasPairWithSum(vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        for (int j = i + 1; j < arr.size(); ++j) {
            if (arr[i] + arr[j] == target)
                return true;
        }
    }
    return false;
}

ğŸ•’ Time Complexity: O(nÂ²)
ğŸ§  Easy to write, but slow for large inputs.

âš¡ 2. What is Hashing?
Hashing uses a data structure like unordered_map or unordered_set (in C++)
to store elements such that lookup, insert, and delete operations are fast (average O(1)).

ğŸ”¸ When to use Hashing:
- When you need to:
  - Check if an element exists
  - Count frequency of elements
  - Detect duplicates
  - Find pairs/subarrays/substrings efficiently
- When time matters and you want to optimize from O(nÂ²) to O(n).

ğŸ”¸ Real-Life Example:
Imagine you want to check if a student exists in your college records.
You don't go searching physically in every class.
Instead, you type their roll number in a system and get the result instantly.
ğŸ‘‰ That is Hashing.

ğŸ”¸ C++ Example: Two Sum (Hashing)
bool hasPairWithSum(vector<int>& arr, int target) {
    unordered_set<int> s;
    for (int x : arr) {
        if (s.count(target - x)) return true;
        s.insert(x);
    }
    return false;
}

ğŸ•’ Time Complexity: O(n)
ğŸ’¾ Space Complexity: O(n)

ğŸ“Œ Comparison Table
| Feature              | Brute Force           | Hashing                     |
|----------------------|------------------------|------------------------------|
| Time Complexity       | O(nÂ²)                  | O(n)                         |
| Space Complexity      | O(1)                   | O(n)                         |
| Uses                  | Try all combinations   | Fast search, lookup          |
| Best For              | Small inputs, learning | Large inputs, optimizations  |

ğŸš¦ When to Use Which?
| Problem Type                        | Recommended Technique      |
|-------------------------------------|-----------------------------|
| Checking if two elements sum to target | Brute â†’ Hashing            |
| Checking if an element exists       | Hashing (unordered_set)     |
| Finding frequency of elements       | Hashing (unordered_map)     |
| Removing duplicates from array      | Hashing                     |
| Longest subarray/substring problems | Hashing + Sliding Window    |

âœ… Final Tip:
âœ”ï¸ Always start with Brute Force if you are new to the problem.
âœ”ï¸ Then optimize with Hashing once your logic is clear.
